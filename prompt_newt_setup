emulate -L zsh
setopt extendedglob

typeset -g -A -H prompt_newt_data

zmodload zsh/parameter

# Preview {{{1

function prompt_newt_preview () {
    local _zsh_theme_preview_euid
    local _zsh_theme_preview_hostname

    print -n "newt theme"
    (( $#* > 0 )) && print -n " with parameters ${(qqq)@[1,-1]}"
    print ":"

    prompt_newt_setup "$@[1,-1]"

    function $0_show () {
        prompt_newt_precmd
        [[ -o promptcr ]] && print -n $'\r'; :
        print -P "${PS1}$*%-0<<${(l:COLUMNS:: :)}${RPS1}"
        #prompt_newt_preexec
    }

    DEFAULT_USER=$USER \
        $0_show "vi README.txt  # Default user, local host"

    USER=root _zsh_theme_preview_euid=0 _zsh_theme_preview_hostname=1 \
        $0_show "rm -rf /       # Root user, remote host"

    unfunction $0_show
}


# Help {{{1

function prompt_newt_help () {
    cat <<EOF
        “She turned me into a newt!”
        “A newt?”
        “… I got better.”

Configuration
-------------

    # Not specific to this theme, but you may want to remove the right-side
    # prompt each time:
    setopt TRANSIENT_RPROMPT
EOF
}


# Drawing Powerline segments {{{1

# + Add a left segment {{{1
function prompt_newt_lsegment () {
    setopt local_options extended_glob
    local bg=none
    local fg=none
    local raw=0
    for arg ($@) {
        [[ $arg = bg:*  ]] && bg=${arg#*:}
        [[ $arg = fg:*  ]] && fg=${arg#*:}
        [[ $arg = raw:* ]] && raw=${arg#*:}
    }

    local seg_separator
    prompt_newt_set_lseg_separator "${bg}" "${fg}"

    local seg_content="$1"
    prompt_newt_finalize_segment $raw

    prompt_result=$seg_content$seg_separator$prompt_result
}

# ++ Determine how to draw the left segment separator {{{1
function prompt_newt_set_lseg_separator () {
    typeset -g seg_separator prompt_b0 prompt_f0
    local b1="$1" f1="$2"

    local lthick_separator=$'\ue0b0'  # 
    local lthin_separator=$'\ue0b1'   # 

    [[ $b1 = none ]] && b1=$prompt_b0
    [[ $f1 = none ]] && f1=$prompt_f0

    seg_separator=
    if [[ $b1 = $prompt_b0 ]]; then
        seg_separator+=$lthin_separator
        [[ $f1 != $prompt_f0 ]] \
            && seg_separator+=$(prompt_newt_fg_color $f0)
    else
        local sepfg="$(prompt_newt_fg_color bg:$b1)"
        seg_separator+=$sepfg
        seg_separator+=$(prompt_newt_bg_color $prompt_b0)
        seg_separator+=$lthick_separator
        local nextfg="$(prompt_newt_fg_color $prompt_f0)"
        [[ $nextfg != $sepfg ]] && seg_separator+=$nextfg
    fi

    prompt_b0=$b1
    prompt_f0=$f1
}

# + Add a right segment {{{1
function prompt_newt_rsegment () {
    setopt local_options extended_glob
    local bg=none
    local fg=none
    local raw=0
    for arg ($@) {
        [[ $arg = bg:*  ]] && bg=${arg#*:}
        [[ $arg = fg:*  ]] && fg=${arg#*:}
        [[ $arg = raw:* ]] && raw=${arg#*:}
    }

    local seg_separator
    prompt_newt_set_rseg_separator "${bg}" "${fg}"

    local seg_content="$1"
    prompt_newt_finalize_segment $raw

    prompt_result+=$seg_separator$seg_content
}

# ++ Determine how to draw the separator for this segment {{{1
function prompt_newt_set_rseg_separator () {
    typeset -g seg_separator prompt_b0 prompt_f0
    local b1="$1" f1="$2"

    local rthick_separator=$'\ue0b2' # 
    local rthin_separator=$'\ue0b3'  # 

    [[ $b1 = none ]] && b1=$prompt_b0
    [[ $f1 = none ]] && f1=$prompt_f0

    seg_separator=
    if [[ $b1 = $prompt_b0 ]]; then
        [[ $f1 != $prompt_f0 ]] \
            && seg_separator+=$(prompt_newt_fg_color $f1)
        seg_separator+=$rthin_separator
    else
        local sepfg=$(prompt_newt_fg_color bg:$b1)
        seg_separator+=$sepfg
        seg_separator+=$rthick_separator
        seg_separator+=$(prompt_newt_bg_color $b1)
        local nextfg=$(prompt_newt_fg_color $f1)
        [[ $nextfg != $sepfg ]] && seg_separator+=$nextfg
    fi

    prompt_b0=$b1
    prompt_f0=$f1
}

# + Resolve color to prompt format escape {{{1
function prompt_newt_bg_color () {
    local c
    case $1 in
        none) c="%K{198}[none]%k" ;;  # Shouldn't happen
        '')
            c="%k"
            ;;
        fg:*)
            c=${1#*:}
            [[ -z $c ]] && c=$(get_terminal_foreground)
            c="%K{$c}"
            ;;
        *)
            c="%K{$1}"
            ;;
    esac
    print -rn $c
}

function prompt_newt_fg_color () {
    local c
    case $1 in
        none) c="%F{198}[none]%f" ;;  # Shouldn't happen
        '')
            c="%f"
            ;;
        bg:*)
            c=${1#*:}
            [[ -z $c ]] && c=$(get_terminal_background)
            c="%F{$c}"
            ;;
        *)
            c="%F{$1}"
            ;;
    esac
    print -rn $c
}

# + Get bg/fg color of terminal {{{1
#   - TODO Use escape sequence to query terminal for color, see
#     http://thrysoee.dk/xtermcontrol/
#     https://github.com/JessThrysoee/xtermcontrol
#     https://superuser.com/questions/157563/programmatic-access-to-current-xterm-background-color
#     Maybe it can be implemented with the zsh/zpty module?

function get_terminal_background () {
    local color

    zstyle -s 'prompt-theme' terminal-background color
    : ${color:=${COLORFGBG#*;}}
    : ${color:=0}
    print -n $color
}

function get_terminal_foreground () {
    local color

    zstyle -s 'prompt-theme' terminal-foreground color
    : ${color:=${COLORFGBG%%;*}}
    : ${color:=15}
    print -n $color
}

# + Finalize a segment's formatting escapes {{{1
function prompt_newt_finalize_segment () {
    typeset -g prompt_b0 prompt_f0 seg_separator seg_content
    local raw="$1"

    if (( !$raw )); then
        zformat -f seg_content "$seg_content" \
            k:$(prompt_newt_bg_color $prompt_b0) \
            f:$(prompt_newt_fg_color $prompt_f0)

        zstyle -t 'prompt-theme:newt:default' compact \
            || [ -z $seg_content ] || seg_content=" $seg_content "
    fi

    function make_truecolor_escape () {
        local n
        [[ $1 = F ]] && n=38 || n=48
        shift;
        printf '%%{\x1b[%d;2;%d;%d;%dm%%}' $n "$@"
    }

    # Change %F{RRR;GGG;BBB} to TrueColor escapes
    seg_separator="${seg_separator//(#bm)%(K|F)\{([0-9]#)\;([0-9]#)\;([0-9]#)\}/$(
            make_truecolor_escape $match[@])}"
    seg_content="${seg_content//(#bm)%(K|F)\{([0-9]#)\;([0-9]#)\;([0-9]#)\}/$(
            make_truecolor_escape $match[@])}"
}


# Prompt precmd hook {{{1
# It must be named like this, or else promptinit won't work properly when
# switching themes. It doesn't call `prompt restore` to clean up.
function prompt_newt_precmd () {
    # This should be first, to save status from user's command
    local save_status=$?

    # Get VCS info
    vcs_info

    # These are state variables used in segment funcs
    # The prompt string being built inside prompt_newt_?segment
    local prompt_result prompt_b0 prompt_f0

    # + Left prompt Segments {{{1

    prompt_result= prompt_b0= prompt_f0=

    prompt_newt_lsegment '%~' bg:4 fg:
    prompt_newt_lsegment '%T' bg:234

    [[ -n $prompt_b0 ]] && prompt_result="$(prompt_newt_bg_color $prompt_b0)$prompt_result"
    [[ -n $prompt_f0 ]] && prompt_result="$(prompt_newt_fg_color $prompt_f0)$prompt_result"

    PS1="${prompt_result} "

    # + Right prompt Segments {{{1

    prompt_result= prompt_b0= prompt_f0=
    if [[ $+MODE_INDICATOR_PROMPT ]]; then
        local indicator
        if [[ -o prompt_subst ]]; then
            indicator='${MODE_INDICATOR_PROMPT}'
        else
            indicator="$MODE_INDICATOR_PROMPT"
        fi
        # XXX Fix me, print only if needed during zle hook
        false && [[ -n $indicator ]] && \
            prompt_newt_rsegment $indicator bg: fg:yellow raw:1
    fi

    local bg=235
    (( $+prompt_newt_data[clobber] )) && bg=160
    unset "prompt_newt_data[clobber]"
    if [[ -n ${vcs_info_msg_0_} ]]; then
        prompt_newt_rsegment ${vcs_info_msg_0_} bg:$bg fg:
    fi

    #prompt_newt_rsegment $save_status bg:235 fg:red


    # Remove a final space, due to ZLE_RPROMPT_INDENT=1
    [[ ${ZLE_RPROMPT_INDENT:-1} -ge 1 ]] && prompt_result=${prompt_result% }

    RPS1="${prompt_result}%b%f%E%k"
}


# VCS_Info hooks for git {{{1

# + $GITDIR {{{1
function +vi-git-show-gitdir () {
    local -a inner
    if (( $+GIT_DIR )); then
        () {
            # See if we're in a shadowed repository
            local GIT_DIR GIT_WORK_TREE
            local verify gitdir
            verify=$(git rev-parse --verify HEAD 2> /dev/null)
            gitdir=$(git rev-parse --git-dir 2> /dev/null)
            inner=($verify $gitdir)
        }

        local verify=$(git rev-parse --verify HEAD 2> /dev/null)
        if [[ -n ${inner[1]} && ${inner[1]} != $verify ]]; then
            # GIT_DIR is shadowing a different repo. This can be
            # very confusing! Stash a flag to trigger an alert.
            prompt_newt_data[clobber]=1
        fi

        local gdir=$'\u2261'"${GIT_DIR/#$HOME/~}"$'\u2261'
        hook_com[branch]="%F{11}$gdir%f %F{15}${hook_com[branch]}"
    fi
}

# + Tracking remote branch? {{{1
function +vi-git-remotebranch () {
    local remote

    # Are we on a remote-tracking branch?
    remote=${$(git rev-parse --verify ${hook_com[branch_orig]}@{upstream} \
        --symbolic-full-name 2>/dev/null)#refs/remotes/}

    # The first test will show a tracking branch whenever there is one. The
    # second test, however, will only show the remote branch's name if it
    # differs from the local one.
    #if [[ -n ${remote} ]] ; then
    if [[ -n ${remote} && ${remote#*/} != ${hook_com[branch_orig]} ]] ; then
        hook_com[branch]+="%F{34}"$'\u00A4'"${remote}"
    fi
}

# + New untracked files? {{{1
function +vi-git-untracked () {
    if [[ $(git rev-parse --is-inside-work-tree 2> /dev/null) = 'true' ]] \
        && git status --porcelain | grep -m 1 '^??' &>/dev/null
    then
        hook_com[misc]+='%F{14}?'
    fi
}

# + Ahead / behind of upstream? {{{1
function +vi-git-st () {
    local b; b="${hook_com[branch_orig]}@{upstream}"

    local ahead;  ahead=$(git  rev-list $b..HEAD 2>/dev/null | wc -l)
    local behind; behind=$(git rev-list HEAD..$b 2>/dev/null | wc -l)

    local -a gitstatus
    (( $ahead ))  && gitstatus+=( "+${ahead}" )
    (( $behind )) && gitstatus+=( "-${behind}" )

    hook_com[misc]+="%F{139}${(j:/:)gitstatus}"
}


# Main Prompt Setup {{{1

function prompt_newt_setup () {
    autoload -Uz add-zsh-hook
    autoload -Uz add-zle-hook-widget
    autoload -Uz vcs_info

    # Use zstyle to stash theme data which is accessible from hooks

    #zstyle ':vcs_info:*' enable git cvs svn bzr hg
    #zstyle ':vcs_info:*+*:*' debug true

    # + Styling {{{1

    zstyle ':vcs_info:git:*' check-for-changes true
    zstyle ':vcs_info:git*'  stagedstr     "%F{10}+"
    zstyle ':vcs_info:git*'  unstagedstr   "%F{11}!"
    zstyle ':vcs_info:*'     formats       '%m%c%u%f[%b%f]'
    zstyle ':vcs_info:*'     actionformats '%F{12}[%b|%a]%f'

    zstyle ':vcs_info:git*+set-message:*' hooks \
        git-show-gitdir \
        git-remotebranch \
        git-st \
        git-untracked \
        # ∴

    # VCS Info TODO - Target setup is: {{{2
    # -   ZSH_THEME_GIT_PROMPT_PREFIX=" "
    # -   ZSH_THEME_GIT_PROMPT_SUFFIX=
    # *%C ZSH_THEME_GIT_PROMPT_CLEAN=
    # *%A ZSH_THEME_GIT_PROMPT_AHEAD="%{$fg[cyan]%}▴"
    # *%B ZSH_THEME_GIT_PROMPT_BEHIND="%{$fg[magenta]%}▾"
    #  %c ZSH_THEME_GIT_PROMPT_STAGED="%{$fg_bold[green]%}●"
    #  %u ZSH_THEME_GIT_PROMPT_UNSTAGED="%{$fg_bold[yellow]%}●"
    # *%T ZSH_THEME_GIT_PROMPT_UNTRACKED="%{$fg_bold[red]%}●"
    #
    # Maybe:
    #     misc="%A/%B %T"  # Presently
    #     zstyle ':vcs_info:*'     formats       ' %m%c%u%T%C%f[%b%f]'
    #     # %D: GIT_DIR; %W: GIT_WORK_TREE; %b: branch; %R: remote
    #     zstyle ':vcs_info:git:*' branchformat  '%D%b%R'
    #     zstyle ':vcs_info:git:*' set-branch-format

    # : ${ZLE_RPROMPT_INDENT=-1}  # {{{2
    # Default is 1, which leaves a space after rprompt. But it's the
    # only reliable setting. And, with the %E format, this won't be
    # noticed because %E *does* color the last cell properly!
    #
    # Value -1 improves some situations, but seems to prevent the last
    # row from being used.
    # http://superuser.com/questions/655607/removing-the-useless-space-at-the-end-of-the-right-prompt-of-zsh-rprompt#comment1505385_726509
    #
    # Value 0 aligns RPROMPT and lets the last row be used, but then the
    # cursor is printed one space to the left; that can be fudged by
    # adding another space at the end of PS1, but display issues abound.
    # XXX Is there a better fix?

    # + Finalization {{{1

    add-zsh-hook precmd prompt_newt_precmd

    prompt_cleanup 'zstyle -d ":prompt-theme:newt"'
    # These should all be user-set configs
    #prompt_cleanup 'zstyle -d ":prompt-theme:newt:*"'

    # Shouldn't need this if everything is put in precmd properly
    #prompt_opts=(cr subst percent)

    return 0
}

[[ -o kshautoload ]] || prompt_newt_setup "$@"

# vim:set sw=4 et ft=zsh fdm=marker:

emulate -L zsh

zmodload zsh/parameter

function ${(%):-%x}_debug () { print -r "$(date) $@" >> /tmp/zsh-debug-newt.log 2>&1 }

# Preview {{{1

function prompt_newt_preview () {
    local _zsh_theme_preview_euid
    local _zsh_theme_preview_hostname

    print -n "newt theme"
    (( $#* > 0 )) && print -n " with parameters ${(qqq)@[1,-1]}"
    print ":"

    prompt_newt_setup "$@[1,-1]"
    prompt_newt_hook precmd

    function $0_show () {
        prompt_newt_assemble_segments left ${(Oa)=prompt_newt_data[left]}
        prompt_newt_assemble_segments right ${=prompt_newt_data[right]}
        [[ -o promptcr ]] && print -n $'\r'; :
        print -P "${PS1}$*%-0<<${(l:COLUMNS:: :)}${RPS1}"
    }

    # Fake vcs info if $PWD isn't
    if [[ -z $prompt_newt_data[+vcs+] ]]; then
        local formats; zstyle -s :vcs_info:\* formats formats
        local str_c; zstyle -s   :vcs_info:\* stagedstr str_c
        local str_u; zstyle -s   :vcs_info:\* unstagedstr str_u
        zformat -f 'prompt_newt_data[+vcs+]' "$formats" \
            m: \
            u:$str_u \
            c:$str_c \
            b:master
        prompt_newt_data[+dir+]='~/code'
    fi
    $0_show "vi README.txt   # Default user, local host, git"

    prompt_newt_data[+dir+]='/etc'
    prompt_newt_data[+dir+state]=root
    prompt_newt_data[+jobs+]=$'\u2699 2'
    prompt_newt_data[+context+]='daffy'
    prompt_newt_data[+vcs+]=''
    prompt_newt_data[+vi_mode+]=SEARCH
    prompt_newt_data[+vi_mode+state]=isearch
    $0_show "rm -rf /  # remote host, root, vi-mode, jobs"

    unfunction $0_show
    prompt_newt_cleanup
}


# Help {{{1

function prompt_newt_help () {
    local br='  '  # Markdown line break

    cat <<EOF
Newt ZSH Theme
==============

>   “She turned me into a newt!”$br
>   “A newt?”$br
>   “… I got better.”$br
EOF

    (( $+PROMPT_NEWT_README )) && cat <<'EOF'

![Newt Theme Preview][preview]

[preview]: https://gist.githubusercontent.com/softmoth/2910577d28970c80b58f8b55c34d58c1/raw/newt-preview.png
EOF

    cat <<'EOF'

Segments
--------

The segments used for left and right prompts can be set with:

    zstyle ':prompt-theme:newt:*' left time context dir
    zstyle ':prompt-theme:newt:*' right vi_mode status jobs vcs

Segments can be configured with the context
`:prompt-theme:newt:STYLE:SEGMENT:STATE`. *Style* can be
anything you like, and you can call `prompt newt STYLE` to
use a particular style. If just `prompt newt` is run, the
style is `default`. *Segment* is the name of the segment, e.g.,
`vcs` or `dir`. *State* is segment-specific, and is `default`
for most segments most of the time.

The settings in use can be shown with `zstyle -L | grep newt`.

Example
-------

    zstyle ':prompt-theme:newt:*:vcs:*'          bg blue
    zstyle ':prompt-theme:newt:*:vcs:*'          fg yellow
    zstyle ':prompt-theme:newt:*:vcs:clobbered'  bg yellow
    zstyle ':prompt-theme:newt:*:vcs:clobbered'  fg red

    zstyle ':prompt-theme:newt:forest:dir:*'     bg green
    zstyle ':prompt-theme:newt:forest:dir:*'     fg blue

    # Only use the left prompt
    zstyle ':prompt-theme:newt:*' left time context status jobs vcs dir
    zstyle ':prompt-theme:newt:*' right none

Vi-mode settings
----------------

The `vi_mode` segment has settings to configure the colors and
text of the mode indicator. The recognized states are `viins`,
`vicmd`, `replace`, `isearch`, `visual` and `vline`. For example,
the `vicmd` mode can be styled with:

    zstyle ':prompt-theme:newt:*:vi_mode' vicmd NORMAL
    zstyle ':prompt-theme:newt:*:vi_mode:vicmd' bg 202
    zstyle ':prompt-theme:newt:*:vi_mode:vicmd' fg 235

Truecolor support
-----------------

If your terminal [supports Truecolor escape sequences][truecolor],
then you can use them anywhere a color can be specified. That is,
either in a `zstyle` to set a color, or directly in a `%K{...}` or
`%F{...}` escape in the prompt text. The color must be given as
`rrr;ggg;bbb`. For example:

    zstyle ':vcs_info:*' stagedstr '%F{250;128;114}+'
    zstyle ':prompt-theme:newt:*:vi_mode:search' bg '199;21;133'

[truecolor]: https://gist.github.com/XVilka/8346728

Miscellaneous settings
----------------------

    # Remove spacing around segments
    zstyle ':prompt-theme:newt:*' compact true

    # Tell newt what color the terminal background is; this is only
    # used to draw the arrow head of the segment separator when the
    # default background (`bg ''`) is used.
    zstyle ':prompt-theme' terminal-background 236

Other settings
--------------

    # See zshcontrib(1) for more options related to version control
    zstyle ':vcs_info:*' enable git cvs svn bzr hg
    zstyle -L ':vcs_info:*'

    # You may want to keep only the latest the right-side prompt
    setopt TRANSIENT_RPROMPT
EOF

    # promptinit doesn't handle cleanup
    [[ $prompt_theme[1] = newt ]] || prompt_newt_cleanup
}


# Drawing Powerline segments {{{1

# + Add a left segment {{{1
function prompt_newt_lsegment () {
    local -A opts
    opts=(bg none fg none raw 0)
    zparseopts -D -A opts -K -- b: f: r

    local seg_separator
    prompt_newt_set_lseg_separator "$opts[-b]" "$opts[-f]"

    local seg_content="$1"
    prompt_newt_finalize_segment "$opts[-r]"

    prompt_result=$seg_content$seg_separator$prompt_result
}

# ++ Determine how to draw the left segment separator {{{1
function prompt_newt_set_lseg_separator () {
    typeset -g seg_separator prompt_b0 prompt_f0
    local b1="$1" f1="$2"

    local lthick_separator=$'\ue0b0'  # 
    local lthin_separator=$'\ue0b1'   # 

    [[ $b1 = none ]] && b1=$prompt_b0
    [[ $f1 = none ]] && f1=$prompt_f0

    seg_separator=
    if [[ $b1 = $prompt_b0 ]]; then
        seg_separator+=$lthin_separator
        [[ $f1 != $prompt_f0 ]] \
            && seg_separator+=$(prompt_newt_fg_color $f0)
    else
        local sepfg="$(prompt_newt_fg_color bg:$b1)"
        seg_separator+=$sepfg
        seg_separator+=$(prompt_newt_bg_color $prompt_b0)
        seg_separator+=$lthick_separator
        local nextfg="$(prompt_newt_fg_color $prompt_f0)"
        [[ $nextfg != $sepfg ]] && seg_separator+=$nextfg
    fi

    prompt_b0=$b1
    prompt_f0=$f1
}

# + Add a right segment {{{1
function prompt_newt_rsegment () {
    local -A opts
    opts=(bg none fg none raw 0)
    zparseopts -D -A opts -K -- b: f: r

    local seg_separator
    prompt_newt_set_rseg_separator "$opts[-b]" "$opts[-f]"

    local seg_content="$1"
    prompt_newt_finalize_segment "$opts[-r]"

    prompt_result+=$seg_separator$seg_content
}

# ++ Determine how to draw the separator for this segment {{{1
function prompt_newt_set_rseg_separator () {
    typeset -g seg_separator prompt_b0 prompt_f0
    local b1="$1" f1="$2"

    local rthick_separator=$'\ue0b2' # 
    local rthin_separator=$'\ue0b3'  # 

    [[ $b1 = none ]] && b1=$prompt_b0
    [[ $f1 = none ]] && f1=$prompt_f0

    seg_separator=
    if [[ $b1 = $prompt_b0 ]]; then
        [[ $f1 != $prompt_f0 ]] \
            && seg_separator+=$(prompt_newt_fg_color $f1)
        seg_separator+=$rthin_separator
    else
        local sepfg=$(prompt_newt_fg_color bg:$b1)
        seg_separator+=$sepfg
        seg_separator+=$rthick_separator
        seg_separator+=$(prompt_newt_bg_color $b1)
        local nextfg=$(prompt_newt_fg_color $f1)
        [[ $nextfg != $sepfg ]] && seg_separator+=$nextfg
    fi

    prompt_b0=$b1
    prompt_f0=$f1
}

# + Resolve color to prompt format escape {{{1
function prompt_newt_bg_color () {
    local c
    case $1 in
        none) c="%K{198}[none]%k" ;;  # Shouldn't happen
        '')
            c="%k"
            ;;
        fg:*)
            c=${1#*:}
            [[ -z $c ]] && c=$(get_terminal_foreground)
            c="%K{$c}"
            ;;
        *)
            c="%K{$1}"
            ;;
    esac
    print -rn $c
}

function prompt_newt_fg_color () {
    local c
    case $1 in
        none) c="%F{198}[none]%f" ;;  # Shouldn't happen
        '')
            c="%f"
            ;;
        bg:*)
            c=${1#*:}
            [[ -z $c ]] && c=$(get_terminal_background)
            c="%F{$c}"
            ;;
        *)
            c="%F{$1}"
            ;;
    esac
    print -rn $c
}

# + Get bg/fg color of terminal {{{1
#   - TODO Use escape sequence to query terminal for color, see
#     http://thrysoee.dk/xtermcontrol/
#     https://github.com/JessThrysoee/xtermcontrol
#     https://superuser.com/questions/157563/programmatic-access-to-current-xterm-background-color
#     Maybe it can be implemented with the zsh/zpty module?

function get_terminal_background () {
    local color

    zstyle -s :prompt-theme terminal-background color
    : ${color:=${COLORFGBG#*;}}
    : ${color:=0}
    print -n $color
}

function get_terminal_foreground () {
    local color

    zstyle -s :prompt-theme terminal-foreground color
    : ${color:=${COLORFGBG%%;*}}
    : ${color:=15}
    print -n $color
}

# + Finalize a segment's formatting escapes {{{1
function prompt_newt_finalize_segment () {
    setopt local_options extended_glob
    typeset -g prompt_b0 prompt_f0 seg_separator seg_content
    local raw="${1:-0}"

    if (( !$raw )); then
        zformat -f seg_content "$seg_content" \
            k:$(prompt_newt_bg_color $prompt_b0) \
            f:$(prompt_newt_fg_color $prompt_f0)

        # Trim whitespace
        seg_content=${${seg_content##[[:space:]]##}%%[[:space:]]##}

        zstyle -t $prompt_newt_data[context] compact \
            || [ -z $seg_content ] || seg_content=" $seg_content "
    fi

    function make_truecolor_escape () {
        local n
        [[ $1 = F ]] && n=38 || n=48
        shift;
        printf '%%{\x1b[%d;2;%d;%d;%dm%%}' $n "$@"
    }

    # Change %F{RRR;GGG;BBB} to TrueColor escapes
    seg_separator="${seg_separator//(#bm)%(K|F)\{([0-9]#)\;([0-9]#)\;([0-9]#)\}/$(
            make_truecolor_escape $match[@])}"
    seg_content="${seg_content//(#bm)%(K|F)\{([0-9]#)\;([0-9]#)\;([0-9]#)\}/$(
            make_truecolor_escape $match[@])}"
}


# VCS_Info hooks for git {{{1

# + $GITDIR {{{1
function +vi-git-show-gitdir () {
    local inner
    if (( $+GIT_DIR )); then
        () {
            # See if we're in a shadowed repository
            local GIT_DIR GIT_WORK_TREE
            inner=$(${vcs_comm[cmd]} rev-parse --verify HEAD 2> /dev/null)
        }

        if [[ -n $inner && $inner != $hook_com[revision] ]]; then
            # GIT_DIR is shadowing a different repo. This can be
            # very confusing! Set a flag to trigger an alert.
            prompt_newt_data[clobber]=1
        fi

        local gdir; print -v gdir -D $GIT_DIR
        gdir="%F{6}$gdir"$'\u2261'"%f"  # ≡
        hook_com[branch]="$gdir${hook_com[branch]}"
    fi
}

# + Tracking remote branch? {{{1
function +vi-git-remotebranch () {
    local remote

    # Are we on a remote-tracking branch?
    remote=${$(${vcs_comm[cmd]} rev-parse --verify ${hook_com[branch_orig]}@{upstream} \
        --symbolic-full-name 2>/dev/null)#refs/remotes/}

    # The first test will show a tracking branch whenever there is one. The
    # second test, however, will only show the remote branch's name if it
    # differs from the local one.
    #if [[ -n ${remote} ]] ; then
    if [[ -n ${remote} && ${remote#*/} != ${hook_com[branch_orig]} ]] ; then
        hook_com[branch]+="%F{3}"$'\u00a4'"${remote}"  # ¤
    fi
}

# + New untracked files? {{{1
function +vi-git-untracked () {
    if [[ $(${vcs_comm[cmd]} rev-parse --is-inside-work-tree 2> /dev/null) = 'true' ]] \
        && ${vcs_comm[cmd]} status --porcelain | command grep -m 1 '^??' &>/dev/null
    then
        local str; zstyle -s :vcs_info:\* untrackedstr str
        hook_com[unstaged]+=${str:-T}
    fi
}

# + Ahead / behind of upstream? {{{1
function +vi-git-upstream () {
    local b; b="${hook_com[branch_orig]}@{upstream}"

    local ahead behind
    ahead=$( ${vcs_comm[cmd]} rev-list $b..HEAD 2>/dev/null | wc -l)
    behind=$(${vcs_comm[cmd]} rev-list HEAD..$b 2>/dev/null | wc -l)

    local -a gitstatus
    (( $ahead ))  && gitstatus+=( $'\u25b4'$ahead )   # ▴
    (( $behind )) && gitstatus+=( $'\u25be'$behind )  # ▾

    (( $#gitstatus )) && hook_com[misc]+="%F{5}${(j:/:)gitstatus}"
}


# Prompt Segments {{{1

# Placeholder to do nothing
function prompt_newt+none+setup () {
}

function prompt_newt+time+precmd () {
    prompt_newt_data[+time+]='%T'
}

function prompt_newt+context+precmd () {
    local u=;
    local h="${(%):-%m}"

    # Only show user if it's other than DEFAULT_USER. Treat root as
    # another default user, since prompt color shows we're privileged.
    [[ $+DEFAULT_USER -eq 1 && $USER != $DEFAULT_USER && $USER != root ]] \
      && u=$USER

    # Hide hostname if on local host (not SSH) or inside tmux (let TMUX
    # status show host info)
    [[ -z $SSH_CLIENT || -n $TMUX ]] && h=
    if [[ -n $h ]]; then
      [[ -n $u ]] && u=${u}@
      u=${u}${h}
    fi

    prompt_newt_data[+context+]=$u
}

function prompt_newt+dir+precmd () {
    prompt_newt_data[+dir+]='%4~'

    [[ $EUID = 0 ]] \
        && prompt_newt_data[+dir+state]=root \
        || prompt_newt_data[+dir+state]=
}

function prompt_newt+vi_mode+setup () {
    local mode
    local ctx=${prompt_newt_data[starcontext]}:vi_mode

    zstyle $ctx viins   ''
    zstyle $ctx vicmd   NORMAL
    zstyle $ctx replace REPLACE
    zstyle $ctx isearch SEARCH
    zstyle $ctx visual  VISUAL
    zstyle $ctx vline   V-LINE

    zstyle ${ctx}:\* bg 8
    zstyle ${ctx}:\* fg 0

    zstyle ${ctx}:vicmd   bg 2
    zstyle ${ctx}:replace bg 6
    zstyle ${ctx}:isearch bg 5
    zstyle ${ctx}:visual  bg 4
    zstyle ${ctx}:vline   bg 4
}

function prompt_newt+vi_mode+zle-keymap-select   () { prompt_newt+vi_mode+hook "$@" }
function prompt_newt+vi_mode+zle-isearch-update  () { prompt_newt+vi_mode+hook "$@" }
function prompt_newt+vi_mode+zle-isearch-exit    () { prompt_newt+vi_mode+hook "$@" }
function prompt_newt+vi_mode+zle-line-pre-redraw () { prompt_newt+vi_mode+hook "$@" }

function prompt_newt+vi_mode+hook () {
    local mode="${VIM_MODE_KEYMAP-$KEYMAP}"
    #${(%):-%x}_debug "vi_mode: ${prompt_newt_data[+vi_mode+state]} -> $mode [$@]"
    case $mode in
        viins|vicmd|replace|isearch|visual|vline) ;;
        main|*) mode=viins ;;
    esac
    [[ $mode = $prompt_newt_data[+vi_mode+state] ]] && return 1
    #${(%):-%x}_debug "       + ${prompt_newt_data[+vi_mode+state]} -> $mode"
    prompt_newt_data[+vi_mode+state]=$mode
    zstyle -s ${prompt_newt_data[context]}:vi_mode $mode 'prompt_newt_data[+vi_mode+]'
}

function prompt_newt+status+setup () {
    prompt_newt_data[save_status]=0
    zstyle ${prompt_newt_data[starcontext]}:status default $'\u2718 %?'  # ✘
    zstyle ${prompt_newt_data[starcontext]}:status zero    ''
}

function prompt_newt+status+precmd () {
    local str
    case $prompt_newt_data[save_status] in
        0|20|148)
            # Ignore suspended command
            zstyle -s ${prompt_newt_data[context]}:status zero str
            ;;
        *)
            zstyle -s ${prompt_newt_data[context]}:status default str
            ;;
    esac
    zformat -f 'prompt_newt_data[+status+]' "$str" \
        '?':$prompt_newt_data[save_status]
}

function prompt_newt+jobs+setup () {
    zstyle ${prompt_newt_data[starcontext]}:jobs default $'\u2699 %j'  # ⚙
    zstyle ${prompt_newt_data[starcontext]}:jobs zero    ''
}

function prompt_newt+jobs+precmd () {
    local ctx=${prompt_newt_data[context]}:jobs
    local jobs
    (( ${(%):-%j} )) \
        && zstyle -s $ctx default 'prompt_newt_data[+jobs+]' \
        || zstyle -s $ctx zero    'prompt_newt_data[+jobs+]'
}

function prompt_newt+vcs+setup () {
    #zstyle :vcs_info:'*+*:*' debug true
    zstyle :vcs_info:\* check-for-changes true
    zstyle :vcs_info:\* stagedstr     $'%F{2}\u25cf'          # ●
    zstyle :vcs_info:\* untrackedstr  $'%F{3}\u25cf'          # ●
    zstyle :vcs_info:\* unstagedstr   $'%F{1}\u25cf'          # ●
    zstyle :vcs_info:\* formats       $'\ue0a0%m%u%c %f%b'    # 
    zstyle :vcs_info:\* actionformats $'\ue0a0 %F{5}%b|%a%f'  # 

    zstyle :vcs_info:git\*+post-backend:\* hooks \
        git-show-gitdir \
        git-remotebranch \
        git-upstream \
        # ∴

    zstyle :vcs_info:git\*+set-message:\* hooks \
        git-untracked \
        # ∴
}

function prompt_newt+vcs+precmd () {
    vcs_info

    if (( $+prompt_newt_data[clobber] )); then
        prompt_newt_data[+vcs+state]=clobbered
    elif [[ ${EUID} = 0 ]]; then
        # Generally a bad idea to use a VCS as root
        prompt_newt_data[+vcs+state]=root
    else
        prompt_newt_data[+vcs+state]=
    fi
    unset 'prompt_newt_data[clobber]'
    prompt_newt_data[+vcs+]=$vcs_info_msg_0_
}


# Update prompt strings {{{1

function prompt_newt_update_prompt () {
    local hook="$1"; shift
    local side="$1"; shift

    #${(%):-%x}_debug "update_prompt: $hook $side $@"
    prompt_newt_do_segments $hook "$@" || return
    prompt_newt_assemble_segments $side "$@"
}

function prompt_newt_do_segments () {
    local hook="$1"; shift
    local changed=0
    local func segment
    for segment in "$@"; do
        func="prompt_newt+$segment+$hook"
        (( ${+functions[$func]} )) || continue
        $func $hook && changed=1
    done

    (( $changed )) || return 1
    return 0
}

function prompt_newt_assemble_segments () {
    local side="$1"; shift

    # These are state variables used in segment funcs
    # The prompt string being built inside prompt_newt_?segment
    local prompt_result= prompt_b0= prompt_f0=

    local func
    [[ $side = left ]] \
        && func=prompt_newt_lsegment \
        || func=prompt_newt_rsegment

    local segment bg fg str ctx
    for segment in "$@"; do
        str=${prompt_newt_data[+${segment}+]}
        [[ -n $str || $prompt_newt_data[+${segment}+show_empty] = 1 ]] || continue
        ctx=${prompt_newt_data[context]}:${segment}:${prompt_newt_data[+${segment}+state]:-default}
        zstyle -s $ctx bg bg
        zstyle -s $ctx fg fg
        $func -b "$bg" -f "$fg" $str
    done

    if [[ $side = left ]]; then
        [[ -n $prompt_b0 ]] && prompt_result="$(prompt_newt_bg_color $prompt_b0)$prompt_result"
        [[ -n $prompt_f0 ]] && prompt_result="$(prompt_newt_fg_color $prompt_f0)$prompt_result"

        PS1="${prompt_result} "
    else
        # Remove a final space, due to ZLE_RPROMPT_INDENT=1
        [[ ${ZLE_RPROMPT_INDENT:-1} -ge 1 ]] \
            && prompt_result="${prompt_result% }%E"

        # Using $reset_color ensures everything is off, and avoids some
        # display problems that may show up with %E%b & truecolor escape
        local reset_color=$'\e[00m'
        RPS1="${prompt_result}%{${reset_color}%}"
    fi
}

function prompt_newt_precmd_save_status () {
    # This should be first, to save status from user's command
    prompt_newt_data[save_status]=$?
}


# Hook function manipulations {{{1

function prompt_newt_list_zsh_hooks () {
    print \
        chpwd precmd preexec periodic \
        zshaddhistory zshexit zsh_directory_name
}

function prompt_newt_list_zle_hooks () {
    print \
        isearch-exit isearch-update line-pre-redraw \
        line-init line-finish history-line-set keymap-select
}

function prompt_newt_add_hooks () {
    local add_func="$1"; shift
    local tag="$1"; shift

    [[ -n $tag ]] && tag="${tag}-"

    local hook func segment
    local -a funcs

    for hook in "$@"; do
        funcs=()
        for segment in ${=prompt_newt_data[left]} ${=prompt_newt_data[right]}; do
            func="prompt_newt+$segment+$tag$hook"
            (( ${+functions[$func]} )) || continue
            funcs+=$func
        done

        (( $#funcs )) || continue

        prompt_newt_data[hooks+$tag$hook]="$funcs"

        func=prompt_newt_hook_$tag$hook
        eval "$func () { prompt_newt_hook $tag$hook \$@ }"
        $add_func $hook $func
    done
}

function prompt_newt_hook () {
    local hook="$1"
    prompt_newt_update_prompt $hook left ${(Oa)=prompt_newt_data[left]}
    prompt_newt_update_prompt $hook right ${=prompt_newt_data[right]}

    if [[ $hook = zle-* ]]; then
        zle reset-prompt
    fi
}

function prompt_newt_delete_hooks () {
    local delete_func="$1"; shift

    # Both use -D to delete based on a pattern
    for hook in "$@"; do
        ${delete_func} -D $hook 'prompt_newt_*'
    done
}


# Cleanup {{{1
function prompt_newt_cleanup () {
    unset prompt_newt_data

    prompt_newt_delete_hooks add-zsh-hook \
        ${=$(prompt_newt_list_zsh_hooks)}

    prompt_newt_delete_hooks add-zle-hook-widget \
        ${=$(prompt_newt_list_zle_hooks)}

    local func
    for func in ${(kM)functions:#prompt_newt[[:punct:]]*}; do
        unset "functions[$func]"
    done

    autoload prompt_newt_setup
}

# Main Prompt Setup {{{1

function prompt_newt_setup () {
    autoload -Uz add-zsh-hook
    autoload -Uz add-zle-hook-widget
    autoload -Uz vcs_info

    typeset -g -A -H prompt_newt_data
    prompt_newt_data=()
    PS1=
    RPS1=

    add-zsh-hook precmd prompt_newt_precmd_save_status

    # + Styling {{{1

    prompt_newt_data[style]=${1:-default}

    prompt_newt_data[starcontext]=:prompt-theme:newt:\*
    local context=:prompt-theme:newt:$prompt_newt_data[style]
    prompt_newt_data[context]=$context

    zstyle -s $context left  'prompt_newt_data[left]'
    zstyle -s $context right 'prompt_newt_data[right]'

    : ${prompt_newt_data[left]:=time context dir}
    : ${prompt_newt_data[right]:=vi_mode status jobs vcs}

    if [[ ${COLORFGBG#*;} = 0 ]]; then
        zstyle ${prompt_newt_data[starcontext]}:\*:\*     bg 7
        zstyle ${prompt_newt_data[starcontext]}:\*:\*     fg 0
    else
        zstyle ${prompt_newt_data[starcontext]}:\*:\*     bg 0
        zstyle ${prompt_newt_data[starcontext]}:\*:\*     fg 7
    fi
    zstyle ${prompt_newt_data[starcontext]}:dir:\*        bg 4
    zstyle ${prompt_newt_data[starcontext]}:dir:root      bg ''
    zstyle ${prompt_newt_data[starcontext]}:dir:root      fg 1
    zstyle ${prompt_newt_data[starcontext]}:status:\*     bg ''
    zstyle ${prompt_newt_data[starcontext]}:status:\*     fg 1
    zstyle ${prompt_newt_data[starcontext]}:vcs:clobbered bg 1
    zstyle ${prompt_newt_data[starcontext]}:vcs:root      bg 1

    zstyle :prompt-theme:newt:forest:\*:\*                bg 22
    zstyle :prompt-theme:newt:forest:\*:\*                fg 229
    zstyle :prompt-theme:newt:forest:dir:\*               bg 24

    prompt_newt_do_segments setup ${=prompt_newt_data[left]}
    prompt_newt_do_segments setup ${=prompt_newt_data[right]}

    # + Finalization {{{1

    prompt_newt_add_hooks add-zsh-hook '' \
        ${=$(prompt_newt_list_zsh_hooks)}

    prompt_newt_add_hooks add-zle-hook-widget zle \
        ${=$(prompt_newt_list_zle_hooks)}

    prompt_cleanup '(( ${+functions[prompt_newt_cleanup]} )) && prompt_newt_cleanup'

    # Shouldn't need this if everything is put in precmd properly
    #prompt_opts=(cr subst percent)

    return 0
}

[[ -o kshautoload ]] || prompt_newt_setup "$@"

# vim:set sw=4 et ft=zsh fdm=marker:

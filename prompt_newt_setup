emulate -L zsh

zmodload zsh/parameter

function ${(%):-%x}_debug () { print -r "$(date) $@" >> /tmp/zsh-debug-newt.log 2>&1 }

# Preview {{{1

function prompt_newt_preview () {
    local _zsh_theme_preview_euid
    local _zsh_theme_preview_hostname

    print -n "newt theme"
    (( $#* > 0 )) && print -n " with parameters ${(qqq)@[1,-1]}"
    print ":"

    prompt_newt_setup "$@[1,-1]"

    function $0_show () {
        prompt_newt_precmd
        [[ -o promptcr ]] && print -n $'\r'; :
        print -P "${PS1}$*%-0<<${(l:COLUMNS:: :)}${RPS1}"
        #prompt_newt_preexec
    }

    DEFAULT_USER=$USER \
        $0_show "vi README.txt  # Default user, local host"

    USER=root _zsh_theme_preview_euid=0 _zsh_theme_preview_hostname=1 \
        $0_show "rm -rf /       # Root user, remote host"

    unfunction $0_show
}


# Help {{{1

function prompt_newt_help () {
    cat <<EOF
        “She turned me into a newt!”
        “A newt?”
        “… I got better.”

Configuration
-------------

    # See zshcontrib(1) for more options related to version control
    zstyle ':vcs_info:*' enable git cvs svn bzr hg

    # Not specific to this theme, but you may want to remove the right-side
    # prompt each time:
    setopt TRANSIENT_RPROMPT
EOF
}


# Drawing Powerline segments {{{1

# + Add a left segment {{{1
function prompt_newt_lsegment () {
    local -A opts
    opts=(bg none fg none raw 0)
    zparseopts -D -A opts -K -- b: f: r

    local seg_separator
    prompt_newt_set_lseg_separator "$opts[-b]" "$opts[-f]"

    local seg_content="$1"
    prompt_newt_finalize_segment "$opts[-r]"

    prompt_result=$seg_content$seg_separator$prompt_result
}

# ++ Determine how to draw the left segment separator {{{1
function prompt_newt_set_lseg_separator () {
    typeset -g seg_separator prompt_b0 prompt_f0
    local b1="$1" f1="$2"

    local lthick_separator=$'\ue0b0'  # 
    local lthin_separator=$'\ue0b1'   # 

    [[ $b1 = none ]] && b1=$prompt_b0
    [[ $f1 = none ]] && f1=$prompt_f0

    seg_separator=
    if [[ $b1 = $prompt_b0 ]]; then
        seg_separator+=$lthin_separator
        [[ $f1 != $prompt_f0 ]] \
            && seg_separator+=$(prompt_newt_fg_color $f0)
    else
        local sepfg="$(prompt_newt_fg_color bg:$b1)"
        seg_separator+=$sepfg
        seg_separator+=$(prompt_newt_bg_color $prompt_b0)
        seg_separator+=$lthick_separator
        local nextfg="$(prompt_newt_fg_color $prompt_f0)"
        [[ $nextfg != $sepfg ]] && seg_separator+=$nextfg
    fi

    prompt_b0=$b1
    prompt_f0=$f1
}

# + Add a right segment {{{1
function prompt_newt_rsegment () {
    local -A opts
    opts=(bg none fg none raw 0)
    zparseopts -D -A opts -K -- b: f: r

    local seg_separator
    prompt_newt_set_rseg_separator "$opts[-b]" "$opts[-f]"

    local seg_content="$1"
    prompt_newt_finalize_segment "$opts[-r]"

    prompt_result+=$seg_separator$seg_content
}

# ++ Determine how to draw the separator for this segment {{{1
function prompt_newt_set_rseg_separator () {
    typeset -g seg_separator prompt_b0 prompt_f0
    local b1="$1" f1="$2"

    local rthick_separator=$'\ue0b2' # 
    local rthin_separator=$'\ue0b3'  # 

    [[ $b1 = none ]] && b1=$prompt_b0
    [[ $f1 = none ]] && f1=$prompt_f0

    seg_separator=
    if [[ $b1 = $prompt_b0 ]]; then
        [[ $f1 != $prompt_f0 ]] \
            && seg_separator+=$(prompt_newt_fg_color $f1)
        seg_separator+=$rthin_separator
    else
        local sepfg=$(prompt_newt_fg_color bg:$b1)
        seg_separator+=$sepfg
        seg_separator+=$rthick_separator
        seg_separator+=$(prompt_newt_bg_color $b1)
        local nextfg=$(prompt_newt_fg_color $f1)
        [[ $nextfg != $sepfg ]] && seg_separator+=$nextfg
    fi

    prompt_b0=$b1
    prompt_f0=$f1
}

# + Resolve color to prompt format escape {{{1
function prompt_newt_bg_color () {
    local c
    case $1 in
        none) c="%K{198}[none]%k" ;;  # Shouldn't happen
        '')
            c="%k"
            ;;
        fg:*)
            c=${1#*:}
            [[ -z $c ]] && c=$(get_terminal_foreground)
            c="%K{$c}"
            ;;
        *)
            c="%K{$1}"
            ;;
    esac
    print -rn $c
}

function prompt_newt_fg_color () {
    local c
    case $1 in
        none) c="%F{198}[none]%f" ;;  # Shouldn't happen
        '')
            c="%f"
            ;;
        bg:*)
            c=${1#*:}
            [[ -z $c ]] && c=$(get_terminal_background)
            c="%F{$c}"
            ;;
        *)
            c="%F{$1}"
            ;;
    esac
    print -rn $c
}

# + Get bg/fg color of terminal {{{1
#   - TODO Use escape sequence to query terminal for color, see
#     http://thrysoee.dk/xtermcontrol/
#     https://github.com/JessThrysoee/xtermcontrol
#     https://superuser.com/questions/157563/programmatic-access-to-current-xterm-background-color
#     Maybe it can be implemented with the zsh/zpty module?

function get_terminal_background () {
    local color

    zstyle -s 'prompt-theme' terminal-background color
    : ${color:=${COLORFGBG#*;}}
    : ${color:=0}
    print -n $color
}

function get_terminal_foreground () {
    local color

    zstyle -s 'prompt-theme' terminal-foreground color
    : ${color:=${COLORFGBG%%;*}}
    : ${color:=15}
    print -n $color
}

# + Finalize a segment's formatting escapes {{{1
function prompt_newt_finalize_segment () {
    setopt local_options extended_glob
    typeset -g prompt_b0 prompt_f0 seg_separator seg_content
    local raw="${1:-0}"

    if (( !$raw )); then
        zformat -f seg_content "$seg_content" \
            k:$(prompt_newt_bg_color $prompt_b0) \
            f:$(prompt_newt_fg_color $prompt_f0)

        zstyle -t 'prompt-theme:newt:default' compact \
            || [ -z $seg_content ] || seg_content=" $seg_content "
    fi

    function make_truecolor_escape () {
        local n
        [[ $1 = F ]] && n=38 || n=48
        shift;
        printf '%%{\x1b[%d;2;%d;%d;%dm%%}' $n "$@"
    }

    # Change %F{RRR;GGG;BBB} to TrueColor escapes
    seg_separator="${seg_separator//(#bm)%(K|F)\{([0-9]#)\;([0-9]#)\;([0-9]#)\}/$(
            make_truecolor_escape $match[@])}"
    seg_content="${seg_content//(#bm)%(K|F)\{([0-9]#)\;([0-9]#)\;([0-9]#)\}/$(
            make_truecolor_escape $match[@])}"
}


# VCS_Info hooks for git {{{1

# + $GITDIR {{{1
function +vi-git-show-gitdir () {
    local inner
    if (( $+GIT_DIR )); then
        () {
            # See if we're in a shadowed repository
            local GIT_DIR GIT_WORK_TREE
            inner=$(${vcs_comm[cmd]} rev-parse --verify HEAD 2> /dev/null)
        }

        if [[ -n $inner && $inner != $hook_com[revision] ]]; then
            # GIT_DIR is shadowing a different repo. This can be
            # very confusing! Set a flag to trigger an alert.
            prompt_newt_data[clobber]=1
        fi

        local gdir; print -v gdir -D $GIT_DIR
        hook_com[branch]="%F{11}$gdir"$'\u2261'"%f%F{15}${hook_com[branch]}"
    fi
}

# + Tracking remote branch? {{{1
function +vi-git-remotebranch () {
    local remote

    # Are we on a remote-tracking branch?
    remote=${$(${vcs_comm[cmd]} rev-parse --verify ${hook_com[branch_orig]}@{upstream} \
        --symbolic-full-name 2>/dev/null)#refs/remotes/}

    # The first test will show a tracking branch whenever there is one. The
    # second test, however, will only show the remote branch's name if it
    # differs from the local one.
    #if [[ -n ${remote} ]] ; then
    if [[ -n ${remote} && ${remote#*/} != ${hook_com[branch_orig]} ]] ; then
        hook_com[branch]+="%F{34}"$'\u00A4'"${remote}"
    fi
}

# + New untracked files? {{{1
function +vi-git-untracked () {
    if [[ $(${vcs_comm[cmd]} rev-parse --is-inside-work-tree 2> /dev/null) = 'true' ]] \
        && ${vcs_comm[cmd]} status --porcelain | grep -m 1 '^??' &>/dev/null
    then
        hook_com[misc]+='%F{14}?'
    fi
}

# + Ahead / behind of upstream? {{{1
function +vi-git-st () {
    local b; b="${hook_com[branch_orig]}@{upstream}"

    local ahead;  ahead=$( ${vcs_comm[cmd]} rev-list $b..HEAD 2>/dev/null | wc -l)
    local behind; behind=$(${vcs_comm[cmd]} rev-list HEAD..$b 2>/dev/null | wc -l)

    local -a gitstatus
    (( $ahead ))  && gitstatus+=( "+${ahead}" )
    (( $behind )) && gitstatus+=( "-${behind}" )

    hook_com[misc]+="%F{139}${(j:/:)gitstatus}"
}


# Prompt Segments {{{1

function prompt_newt+time+precmd () {
    prompt_newt_data[+time+]='%T'
}

function prompt_newt+context+precmd () {
    local u=;
    local h; print -v h -P '%m'

    # Only show user if it's other than DEFAULT_USER. Treat root as
    # another default user, since prompt color shows we're privileged.
    [[ $+DEFAULT_USER -eq 1 && $USER != $DEFAULT_USER && $USER != root ]] \
      && u=$USER

    # Hide hostname if on local host (not SSH) or inside tmux (let TMUX
    # status show host info)
    [[ -z $SSH_CLIENT || -n $TMUX ]] && h=
    if [[ -n $h ]]; then
      [[ -n $u ]] && u=${u}@
      u=${u}${h}
    fi

    prompt_newt_data[+context+]=$u
}

function prompt_newt+dir+precmd () {
    prompt_newt_data[+dir+]='%~'

    [[ $EUID = 0 ]] \
        && prompt_newt_data[+dir+state]=root \
        || prompt_newt_data[+dir+state]=
}

function prompt_newt+vi_mode+setup () {
    local mode
    local ctx="$prompt_newt_data[defcontext]:vi_mode"

    zstyle $ctx viins ''
    zstyle $ctx vicmd 'NORMAL'
    zstyle $ctx replace 'REPLACE'
    zstyle $ctx isearch 'SEARCH'
    zstyle $ctx visual 'VISUAL'
    zstyle $ctx vline 'V-LINE'

    zstyle "$ctx:*" bg '8'
    zstyle "$ctx:*" fg '0'

    zstyle "$ctx:vicmd" bg '2'
    zstyle "$ctx:replace" bg '6'
    zstyle "$ctx:isearch" bg '5'
    zstyle "$ctx:visual" bg '4'
    zstyle "$ctx:vline" bg '4'
}

#function prompt_newt+vi_mode+precmd              () { prompt_newt+vi_mode+hook "$@" }
#function prompt_newt+vi_mode+zle-line-init       () { prompt_newt+vi_mode+hook "$@" }
function prompt_newt+vi_mode+zle-keymap-select   () { prompt_newt+vi_mode+hook "$@" }
function prompt_newt+vi_mode+zle-isearch-update  () { prompt_newt+vi_mode+hook "$@" }
function prompt_newt+vi_mode+zle-isearch-exit    () { prompt_newt+vi_mode+hook "$@" }
function prompt_newt+vi_mode+zle-line-pre-redraw () { prompt_newt+vi_mode+hook "$@" }

function prompt_newt+vi_mode+hook () {
    local mode="${VIM_MODE_KEYMAP-$KEYMAP}"
    #${(%):-%x}_debug "vi_mode: ${prompt_newt_data[+vi_mode+state]} -> $mode [$@]"
    case $mode in
        viins|vicmd|replace|isearch|visual|vline) ;;
        main|*) mode=viins ;;
    esac
    [[ $mode = $prompt_newt_data[+vi_mode+state] ]] && return 1
    #${(%):-%x}_debug "       + ${prompt_newt_data[+vi_mode+state]} -> $mode"
    prompt_newt_data[+vi_mode+state]=$mode
    noglob zstyle -s "${prompt_newt_data[context]}:vi_mode" $mode prompt_newt_data[+vi_mode+]
}

function prompt_newt+status+precmd () {
    case $prompt_newt_data[save_status] in
        0|20|148)
            # Ignore suspended command
            prompt_newt_data[+status+]=
            ;;
        *)
            prompt_newt_data[+status+]=$prompt_newt_data[save_status]
            ;;
    esac
}

function prompt_newt+jobs+precmd () {
    local jobs; print -v jobs -P '%j'
    if (( $jobs )); then
    else
        jobs=
    fi
    prompt_newt_data[+jobs+]=$jobs
}

function prompt_newt+vcs+setup () {
    # VCS Info TODO - Target setup is: {{{2
    # -   ZSH_THEME_GIT_PROMPT_PREFIX=" "
    # -   ZSH_THEME_GIT_PROMPT_SUFFIX=
    # *%C ZSH_THEME_GIT_PROMPT_CLEAN=
    # *%A ZSH_THEME_GIT_PROMPT_AHEAD="%{$fg[cyan]%}▴"
    # *%B ZSH_THEME_GIT_PROMPT_BEHIND="%{$fg[magenta]%}▾"
    #  %c ZSH_THEME_GIT_PROMPT_STAGED="%{$fg_bold[green]%}●"
    #  %u ZSH_THEME_GIT_PROMPT_UNSTAGED="%{$fg_bold[yellow]%}●"
    # *%T ZSH_THEME_GIT_PROMPT_UNTRACKED="%{$fg_bold[red]%}●"
    #
    # Maybe:
    #     misc="%A/%B %T"  # Presently
    #     zstyle ':vcs_info:*'     formats       ' %m%c%u%T%C%f[%b%f]'
    #     # %D: GIT_DIR; %W: GIT_WORK_TREE; %b: branch; %R: remote
    #     zstyle ':vcs_info:git:*' branchformat  '%D%b%R'
    #     zstyle ':vcs_info:git:*' set-branch-format
    # }}}

    #zstyle ':vcs_info:*+*:*' debug true
    zstyle ':vcs_info:*' check-for-changes true
    zstyle ':vcs_info:*' stagedstr     "%F{10}+"
    zstyle ':vcs_info:*' unstagedstr   "%F{11}!"
    zstyle ':vcs_info:*' formats       '%m%c%u%f[%b%f]'
    zstyle ':vcs_info:*' actionformats '%F{12}[%b|%a]%f'

    zstyle ':vcs_info:git*+post-backend:*' hooks \
        git-show-gitdir \
        git-remotebranch \
        git-st \
        git-untracked \
        # ∴
}

function prompt_newt+vcs+precmd () {
    vcs_info

    (( $+prompt_newt_data[clobber] )) \
        && prompt_newt_data[+vcs+state]=clobbered \
        || prompt_newt_data[+vcs+state]=
    noglob unset prompt_newt_data[clobber]
    prompt_newt_data[+vcs+]=$vcs_info_msg_0_
}


# Update prompt strings {{{1

function prompt_newt_update_prompt () {
    local hook="$1"; shift
    local side="$1"; shift
    local func
    local segment

    #${(%):-%x}_debug "hook: $hook $side $@"
    prompt_newt_do_segments $hook "$@" || return

    # These are state variables used in segment funcs
    # The prompt string being built inside prompt_newt_?segment
    local prompt_result= prompt_b0= prompt_f0=


    [[ $side = left ]] \
        && func=prompt_newt_lsegment \
        || func=prompt_newt_rsegment

    local bg fg str ctx
    for segment in "$@"; do
        str=${prompt_newt_data[+${segment}+]}
        [[ -n $str || $prompt_newt_data[+${segment}+show_empty] = 1 ]] || continue
        ctx="${prompt_newt_data[context]}:$segment:${prompt_newt_data[+${segment}+state]:-default}"
        zstyle -s "$ctx" bg bg
        zstyle -s "$ctx" fg fg
        #${(%):-%x}_debug "'$ctx' bg:$bg fg:$fg vcs:${prompt_newt_bg_color[+vcs+state]}"
        $func -b "$bg" -f "$fg" $str
    done

    if [[ $side = left ]]; then
        [[ -n $prompt_b0 ]] && prompt_result="$(prompt_newt_bg_color $prompt_b0)$prompt_result"
        [[ -n $prompt_f0 ]] && prompt_result="$(prompt_newt_fg_color $prompt_f0)$prompt_result"

        PS1="${prompt_result} "
    else
        # Remove a final space, due to ZLE_RPROMPT_INDENT=1
        [[ ${ZLE_RPROMPT_INDENT:-1} -ge 1 ]] \
            && prompt_result="${prompt_result% }%E"

        RPS1="${prompt_result}%b%f%E%k"
        RPROMPT=$RPS1
    fi
}

function prompt_newt_do_segments () {
    local hook="$1"; shift
    local changed=0
    local func segment
    for segment in "$@"; do
        func="prompt_newt+$segment+$hook"
        (( ${+functions[$func]} )) || continue
        $func $hook && changed=1
    done

    (( $changed )) || return 1
    return 0
}

function prompt_newt_precmd_save_status () {
    # This should be first, to save status from user's command
    prompt_newt_data[save_status]=$?
}

function prompt_newt_add_zsh_hooks () {
    prompt_newt_add_hooks add-zsh-hook '' \
        chpwd precmd preexec periodic zshaddhistory zshexit zsh_directory_name
}

function prompt_newt_add_zle_hooks () {
    prompt_newt_add_hooks add-zle-hook-widget zle \
        isearch-exit isearch-update line-pre-redraw \
        line-init line-finish history-line-set keymap-select
}

function prompt_newt_add_hooks () {
    local add_func="$1"; shift
    local tag="$1"; shift

    [[ -n $tag ]] && tag="${tag}-"

    local func segment
    local -a funcs

    for hook in "$@"; do
        funcs=()
        for segment in ${=prompt_newt_data[left]} ${=prompt_newt_data[right]}; do
            func="prompt_newt+$segment+$tag$hook"
            (( ${+functions[$func]} )) || continue
            funcs+=$func
        done

        (( $#funcs )) || continue

        prompt_newt_data[hooks+$tag$hook]="$funcs"

        func=prompt_newt_hook_$tag$hook
        eval "$func () { prompt_newt_hook $tag$hook \$@ }"
        $add_func $hook $func
    done
}


function prompt_newt_hook () {
    local hook="$1"
    prompt_newt_update_prompt $hook left ${(Oa)=prompt_newt_data[left]}
    prompt_newt_update_prompt $hook right ${=prompt_newt_data[right]}

    if [[ $hook = zle-* ]]; then
        zle reset-prompt
    fi
}


# Main Prompt Setup {{{1

function prompt_newt_setup () {
    autoload -Uz add-zsh-hook
    autoload -Uz add-zle-hook-widget
    autoload -Uz vcs_info

    typeset -g -A -H prompt_newt_data
    prompt_newt_data=()
    add-zsh-hook precmd prompt_newt_precmd_save_status

    # + Styling {{{1

    prompt_newt_data[style]=${1:-default}

    prompt_newt_data[defcontext]=':prompt-theme:newt:*'
    local context=":prompt-theme:newt:$prompt_newt_data[style]"
    prompt_newt_data[context]=$context

    noglob zstyle -s $context left prompt_newt_data[left]
    noglob zstyle -s $context right prompt_newt_data[right]

    : ${prompt_newt_data[left]:=time context dir}
    : ${prompt_newt_data[right]:=vi_mode status jobs vcs}

    zstyle "${prompt_newt_data[defcontext]}:context:*"     bg none
    zstyle "${prompt_newt_data[defcontext]}:context:*"     fg none
    zstyle "${prompt_newt_data[defcontext]}:dir:*"         bg 4
    zstyle "${prompt_newt_data[defcontext]}:dir:*"         fg 0
    zstyle "${prompt_newt_data[defcontext]}:dir:root"      bg ''
    zstyle "${prompt_newt_data[defcontext]}:dir:root"      fg 9
    zstyle "${prompt_newt_data[defcontext]}:status:*"      bg ''
    zstyle "${prompt_newt_data[defcontext]}:status:*"      fg 1
    zstyle "${prompt_newt_data[defcontext]}:time:*"        bg 8
    zstyle "${prompt_newt_data[defcontext]}:time:*"        fg 15
    zstyle "${prompt_newt_data[defcontext]}:vcs:clobbered" bg 9
    zstyle "${prompt_newt_data[defcontext]}:vcs:*"         bg 8
    zstyle "${prompt_newt_data[defcontext]}:vcs:*"         fg 0

    prompt_newt_do_segments setup ${=prompt_newt_data[left]}
    prompt_newt_do_segments setup ${=prompt_newt_data[right]}

    # + Finalization {{{1

    prompt_newt_add_zsh_hooks
    prompt_newt_add_zle_hooks

    prompt_cleanup 'unset prompt_newt_data'

    # Shouldn't need this if everything is put in precmd properly
    #prompt_opts=(cr subst percent)

    return 0
}

[[ -o kshautoload ]] || prompt_newt_setup "$@"

# vim:set sw=4 et ft=zsh fdm=marker:
